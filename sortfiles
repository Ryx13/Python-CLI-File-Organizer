#!/usr/bin/env python3

import os
import shutil
import argparse
from pathlib import Path

# --- CONFIGURATION ---
CATEGORIES = {
    "Images":    ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.tiff', '.ico'],
    "Videos":    ['.mp4', '.mkv', '.mov', '.avi', '.flv', '.wmv', '.webm', '.m4v'],
    "Music":     ['.mp3', '.wav', '.aac', '.flac', '.ogg', '.wma', '.m4a'],
    "Documents": ['.pdf', '.docx', '.doc', '.txt', '.xlsx', '.xls', '.pptx', '.ppt', '.csv', '.md', '.odt'],
    "Archives":  ['.zip', '.rar', '.tar', '.gz', '.7z', '.iso', '.bz2', '.xz'],
    "Scripts":   ['.py', '.sh', '.js', '.php', '.html', '.css', '.cpp', '.c', '.java', '.rb', '.pl'],
    "Executables": ['.exe', '.msi', '.deb', '.rpm', '.bin', '.appimage']
}

def get_category(extension):
    """Finds the category key based on the file extension."""
    for category, extensions in CATEGORIES.items():
        if extension.lower() in extensions:
            return category
    return "Others"

def get_unique_filename(destination_folder, filename):
    """
    Checks if a file exists. If it does, appends a counter 
    (e.g., file_1.txt) to avoid overwriting.
    """
    name, ext = os.path.splitext(filename)
    counter = 1
    new_filename = filename
    destination_path = destination_folder / new_filename

    while destination_path.exists():
        new_filename = f"{name}_{counter}{ext}"
        destination_path = destination_folder / new_filename
        counter += 1
    
    return destination_path

def sort_files(target_dir, dry_run=False):
    target_path = Path(target_dir)

    if not target_path.exists():
        print(f"Error: The directory '{target_dir}' does not exist.")
        return

    print(f"Scanning directory: {target_path}")
    if dry_run:
        print("--- DRY RUN MODE: No files will be moved ---")

    files_moved = 0

    # Iterate over items in the directory
    for item in target_path.iterdir():
        # SAFETY CHECK 1: Ignore Hidden Files
        if item.name.startswith('.'):
            continue
        
        # SAFETY CHECK 2: Non-Recursive (Skip Directories)
        if item.is_dir():
            continue

        # Determine Category
        category = get_category(item.suffix)
        dest_folder = target_path / category

        # Calculate final path with conflict handling
        final_path = get_unique_filename(dest_folder, item.name)

        # Action Phase
        if dry_run:
            print(f"[Would Move] {item.name} -> {category}/{final_path.name}")
        else:
            # Create category folder if it doesn't exist
            dest_folder.mkdir(exist_ok=True)
            
            try:
                shutil.move(str(item), str(final_path))
                print(f"[Moved] {item.name} -> {category}/{final_path.name}")
                files_moved += 1
            except Exception as e:
                print(f"[Error] Could not move {item.name}: {e}")

    if dry_run:
        print("\nDry run complete. No changes made.")
    else:
        print(f"\nDone! Sorted {files_moved} files.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Sort files in a directory by extension.")
    parser.add_argument("path", help="The directory path to sort (e.g., /home/kali/Downloads)")
    parser.add_argument("--dry-run", action="store_true", help="Simulate the sorting without moving files")
    
    args = parser.parse_args()
    
    sort_files(args.path, args.dry_run)
